# PostgreSQL Schema Documentation

## Overview

This document management system uses PostgreSQL to store and manage documents with support for:
- Document storage with version control
- B2B multi-tenant organization structure
- Graph-based document relationships
- Topic modeling and document clustering
- Tool/agent attribution for content generation

## Schema Structure

### Core Entities

#### Organizations
The root entity for B2B multi-tenancy.
```sql
CREATE TABLE organizations (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```
- **Primary Key**: `id` (auto-incrementing)
- **Constraints**: Name cannot be empty
- **Usage**: Represents a business tenant in the system

#### Users
Users belong to organizations and can own documents.
```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username TEXT NOT NULL UNIQUE,
  email TEXT NOT NULL UNIQUE,
  org_id INTEGER NOT NULL REFERENCES organizations(id),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```
- **Primary Key**: `id` (auto-incrementing)
- **Foreign Keys**: `org_id` references organizations
- **Constraints**: Username and email must be unique, email format validation
- **Usage**: Represents system users who can own and manage documents

#### Documents
Core document storage with ownership and metadata.
```sql
CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  owner_id INTEGER NOT NULL REFERENCES users(id),
  org_id INTEGER NOT NULL REFERENCES organizations(id),
  document_type VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  version INTEGER NOT NULL DEFAULT 1,
  file_format VARCHAR(50),
  size_bytes INTEGER,
  word_count INTEGER,
  processing_status VARCHAR(50) DEFAULT 'pending',
  source VARCHAR(100),
  content_hash VARCHAR(64),
  external_ref_id VARCHAR(100),
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```
- **Primary Key**: `id` (auto-incrementing)
- **Foreign Keys**: 
  - `owner_id` references users
  - `org_id` references organizations
- **Constraints**:
  - Title cannot be empty
  - Status must be one of: 'draft', 'published', 'archived', 'deleted'
  - Version must be positive
  - Processing status must be one of: 'pending', 'processing', 'complete', 'error'
- **Usage**: Stores document content and metadata

### Document Analysis

#### Summaries
Stores document summaries generated by various tools/agents.
```sql
CREATE TABLE summaries (
  id SERIAL PRIMARY KEY,
  document_id INTEGER NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  summary_type VARCHAR(50) NOT NULL,
  target_audience VARCHAR(50),
  tool_agent VARCHAR(100) NOT NULL,
  tool_version VARCHAR(50),
  config_parameters JSONB,
  confidence_score DECIMAL(5,4),
  word_count INTEGER,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```
- **Primary Key**: `id` (auto-incrementing)
- **Foreign Keys**: `document_id` references documents (cascade delete)
- **Usage**: Stores AI-generated summaries with metadata about the generation process

## Common Query Patterns

### Document Retrieval

1. Get document with latest summary:
```sql
SELECT d.*, s.*
FROM documents d
LEFT JOIN summaries s ON d.id = s.document_id
WHERE d.id = $1
ORDER BY s.created_at DESC
LIMIT 1;
```

2. Find documents by organization:
```sql
SELECT d.*
FROM documents d
WHERE d.org_id = $1
ORDER BY d.updated_at DESC
LIMIT $2 OFFSET $3;
```

### Access Control Queries

1. Check user's access to document:
```sql
SELECT EXISTS (
  SELECT 1
  FROM documents d
  JOIN users u ON d.owner_id = u.id
  WHERE d.id = $1 
  AND u.org_id = $2
);
```

## Performance Considerations

### Key Indexes
The schema includes carefully chosen indexes to optimize common query patterns:

1. Document lookup indexes:
```sql
CREATE INDEX idx_documents_owner ON documents(owner_id);
CREATE INDEX idx_documents_organization ON documents(org_id);
CREATE INDEX idx_documents_type_status ON documents(document_type, status);
CREATE INDEX idx_documents_created ON documents(created_at);
```

2. Full-text search indexes:
```sql
CREATE INDEX idx_documents_title_tsvector ON documents USING GIN (to_tsvector('english', title));
CREATE INDEX idx_documents_content_tsvector ON documents USING GIN (to_tsvector('english', content));
```

### Query Optimization Tips

1. Always include organization_id in filters when possible
2. Use prepared statements for repeated queries
3. Use LIMIT and OFFSET for pagination
4. Consider materialized views for complex aggregations
5. Use batch operations for bulk inserts/updates

## Best Practices

### Transaction Management

Always use transactions for operations that modify multiple tables:

```sql
BEGIN;
-- Insert document
INSERT INTO documents (title, content, owner_id, org_id, document_type)
VALUES ($1, $2, $3, $4, $5)
RETURNING id;

-- Insert summary
INSERT INTO summaries (document_id, content, summary_type, tool_agent)
VALUES ($1, $2, $3, $4);
COMMIT;
```

### Error Handling

1. Use explicit error handling in applications
2. Implement retry logic for transient failures
3. Log database errors with context
4. Use appropriate isolation levels

### Maintenance Tasks

1. Regular VACUUM ANALYZE for statistics updates
2. Monitor index usage and remove unused indexes
3. Review and update table statistics periodically
4. Monitor and manage table bloat

## Schema Migration Guidelines

1. Always version control migration scripts
2. Include both up and down migrations
3. Test migrations on copy of production data
4. Document breaking changes
5. Consider impact on existing queries
