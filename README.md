# AXAI PostgreSQL Models

This package provides PostgreSQL models and database management for AXAI applications. It includes a comprehensive set of models for managing organizations, users, documents, topics, and their relationships.

## Installation

### For Production Use

```bash
pip install axai-pg
```

### For Development

```bash
# Clone the repository
git clone <repository-url>
cd axai-pg

# Install dependencies
pip install -r requirements.txt

# Or install in editable mode with testing extras
pip install -e ".[testing]"
```

### Prerequisites

- Python >=3.8
- PostgreSQL 12 or later
- Docker and Docker Compose (for running tests)

## Usage

### Basic Setup

```python
from axai_pg import DatabaseManager, PostgresConnectionConfig
from axai_pg import Organization, User, Document, Summary, Topic

# Initialize the database connection
conn_config = PostgresConnectionConfig(
    host="localhost",  # or "postgres" if in same docker network
    port=5432,
    database="your_db",
    username="your_user",
    password="your_password"
)
DatabaseManager.initialize(conn_config)

# Get a database session
db = DatabaseManager.get_instance()
```

### Creating and Managing Data

```python
# Create an organization and a user
with db.session_scope() as session:
    # Create an organization
    org = Organization(name="Test Organization")
    session.add(org)
    session.flush()  # This gets us the org.id
    
    # Create a user in that organization
    user = User(
        username="testuser",
        email="test@example.com",
        org_id=org.id
    )
    session.add(user)
    session.flush()  # This gets us the user.id
    
    # Create a document
    document = Document(
        title="Test Document",
        content="This is a test document content",
        owner_id=user.id,
        org_id=org.id,
        document_type="text",
        status="draft"
    )
    session.add(document)
    session.flush()  # This gets us the document.id
    
    # Create a summary for the document
    summary = Summary(
        document_id=document.id,
        content="This is a summary of the test document",
        summary_type="abstract",
        tool_agent="test-agent",
        confidence_score=0.95
    )
    session.add(summary)
    
    # Create a topic
    topic = Topic(
        name="Test Topic",
        description="A test topic",
        keywords=["test", "example"],
        extraction_method="manual",
        global_importance=0.8
    )
    session.add(topic)
    
    # The session will automatically commit when the context manager exits
```

### Querying Data

```python
with db.session_scope() as session:
    # Get all organizations
    organizations = session.query(Organization).all()
    
    # Get a specific user
    user = session.query(User).filter_by(username="testuser").first()
    
    # Get all documents for an organization
    org_documents = session.query(Document).filter_by(org_id=org.id).all()
    
    # Get documents with their summaries
    documents_with_summaries = (
        session.query(Document, Summary)
        .join(Summary)
        .filter(Document.org_id == org.id)
        .all()
    )
```

### Using in FastAPI Applications

```python
from fastapi import FastAPI, Depends
from axai_pg import DatabaseManager, PostgresConnectionConfig
from axai_pg import Organization, User

app = FastAPI()

# Database dependency
def get_db():
    db = DatabaseManager.get_instance()
    with db.session_scope() as session:
        yield session

@app.post("/organizations/")
async def create_organization(org: dict, session = Depends(get_db)):
    organization = Organization(name=org["name"])
    session.add(organization)
    session.flush()
    return {"id": organization.id, "name": organization.name}

@app.get("/users/{user_id}")
async def get_user(user_id: int, session = Depends(get_db)):
    user = session.query(User).filter_by(id=user_id).first()
    return user
```

### Using in Django Applications

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_db',
        'USER': 'your_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}

# views.py
from django.http import JsonResponse
from axai_pg import DatabaseManager, PostgresConnectionConfig
from axai_pg import Organization, User

def create_organization(request):
    db = DatabaseManager.get_instance()
    with db.session_scope() as session:
        org = Organization(name=request.POST['name'])
        session.add(org)
        session.flush()
        return JsonResponse({'id': org.id, 'name': org.name})
```

## Models

The package includes the following models:

- Organization: Represents B2B tenants in the multi-tenant system
- User: Users belonging to organizations
- Document: Core document storage with ownership and metadata
- DocumentVersion: Historical versions of documents
- Summary: Document summaries generated by various tools/agents
- Topic: Topics extracted from document content
- GraphNode: Nodes for the graph representation of document connections
- GraphRelationship: Relationships between nodes in the document graph

## Development

To install the package in development mode:

```bash
git clone https://github.com/your-org/axai-pg.git
cd axai-pg
pip install -e .
```

## Testing

All tests use a real PostgreSQL database for accuracy and reliability. The database schema is created programmatically using SQLAlchemy models with PostgreSQL-specific features (triggers, check constraints, indexes, etc.).

### Quick Start

1. **Install dependencies**:
```bash
pip install -r requirements.txt
```

2. **Start the test database**:
```bash
docker-compose -f docker-compose.standalone-test.yml up -d
```

3. **Run the tests**:
```bash
# Run all integration tests
pytest tests/integration/ -v --integration

# Run specific test file
pytest tests/integration/test_schema_creation.py -v --integration

# Run with coverage (if pytest-cov is installed)
pytest tests/ -v --integration --cov=src --cov-report=term-missing
```

4. **Clean up**:
```bash
docker-compose -f docker-compose.standalone-test.yml down -v
```

### Test Database Configuration

The test database uses the following credentials (from `docker-compose.standalone-test.yml`):
- **Host**: localhost
- **Port**: 5432
- **Database**: test_db
- **Username**: test_user
- **Password**: test_password

These match the defaults in `tests/conftest.py`. You can override by setting the `TEST_DATABASE_URL` environment variable:

```bash
export TEST_DATABASE_URL="postgresql://user:password@localhost:5432/my_test_db"
pytest tests/integration/ -v --integration
```

### SQLAlchemy-First Schema Approach

The project uses **SQLAlchemy models as the single source of truth** for schema definition. The schema is created programmatically via `PostgreSQLSchemaBuilder`, which:

1. Creates PostgreSQL extensions (uuid-ossp)
2. Creates custom trigger functions (auto-update timestamps)
3. Creates tables from SQLAlchemy models (`Base.metadata.create_all`)
4. Creates triggers for each table
5. Adds table comments
6. Creates performance indexes

The old SQL files in `sql/schema/` are deprecated and kept only for reference.

### Test Organization

- **`tests/integration/`**: All tests use real PostgreSQL (no mocks)
  - `test_schema_creation.py`: Comprehensive schema validation tests
- **`tests/conftest.py`**: Test fixtures and database setup

### Test Fixtures

- **`test_engine`**: Session-scoped SQLAlchemy engine
- **`db_session`**: Function-scoped session with automatic transaction rollback
- **`real_db_session`**: Alias for `db_session` (backward compatibility)
- **`test_data`**: Sample data fixtures

### Writing Tests

```python
@pytest.mark.integration
def test_something(db_session):
    # Create test data
    user = User(username="testuser", email="test@example.com")
    db_session.add(user)
    db_session.commit()
    
    # Query the database
    result = db_session.query(User).filter_by(username="testuser").first()
    assert result is not None
    assert result.email == "test@example.com"
```

### Test Organization

- `tests/integration/`: Integration tests with real database
- `tests/docker_integration/`: Docker-based tests
- `tests/conftest.py`: Test configuration and fixtures

### Database Reset

For development and testing purposes, you can use the `reset_db.sh` script to quickly reset the database to a clean state. This script will:
1. Drop the existing database
2. Create a new database
3. Apply the schema
4. Optionally load sample data

To use the reset script:

```bash
# Make sure the script is executable
chmod +x reset_db.sh

# Basic reset (schema only, no sample data)
./reset_db.sh
```

Note: The script requires that the Docker container `axai-pg-test` is running. If you get an error about the container not running, make sure to start it first:

```bash
docker-compose -f docker-compose.test.yml up -d
```

## Integration Testing with Other Systems

The axai-pg package provides utilities to simplify integration testing for external systems that use this package.

### Quick Start for External Systems

1. **Install with testing extras**:
```bash
pip install axai-pg[testing]
```

2. **Start the test database**:
```bash
docker-compose -f docker-compose.standalone-test.yml up -d
```

3. **Use pytest fixtures in your tests**:
```python
from axai_pg.testing.fixtures import axai_db_session
from axai_pg.data.models import Organization, User

def test_my_feature(axai_db_session):
    # Create test data
    org = Organization(name="Test Org")
    axai_db_session.add(org)
    axai_db_session.commit()

    # Run your tests
    assert axai_db_session.query(Organization).count() == 1
    # Session automatically rolls back after test
```

### Programmatic Database Initialization

For non-pytest scenarios or custom test setups:

```python
from axai_pg.utils import DatabaseInitializer, DatabaseInitializerConfig
from axai_pg.data.config.database import PostgresConnectionConfig

# Configure database
conn_config = PostgresConnectionConfig(
    host='localhost',
    port=5432,
    database='test_db',
    username='test_user',
    password='test_password'
)

config = DatabaseInitializerConfig(
    connection_config=conn_config,
    auto_create_db=True,
    auto_drop_on_exit=True  # Automatic cleanup
)

# Use context manager for automatic setup/teardown
with DatabaseInitializer(config) as db_init:
    db_init.setup_database()

    # Run your tests
    with db_init.session_scope() as session:
        # Perform database operations
        pass

# Database is automatically cleaned up
```

### Available Pytest Fixtures

- **`axai_db_config`**: Connection configuration
- **`axai_test_db`**: Session-scoped database initialization
- **`axai_db_session`**: Function-scoped session with automatic rollback
- **`axai_db_manager`**: Direct access to DatabaseManager
- **`axai_clean_db_session`**: Session without rollback (commits changes)
- **`axai_reset_db`**: Reset database to clean state

### Environment Variables

Configure the test database using environment variables:

```bash
export POSTGRES_HOST=localhost
export POSTGRES_PORT=5432
export POSTGRES_DB=test_db
export POSTGRES_USER=test_user
export POSTGRES_PASSWORD=test_password

# Optional: Auto-drop database after tests
export AXAI_AUTO_DROP_DB=true

# Optional: Load sample data
export AXAI_LOAD_SAMPLE_DATA=true
```

### Docker Compose for CI/CD

The `docker-compose.standalone-test.yml` file provides a minimal PostgreSQL setup perfect for CI/CD pipelines:

```yaml
# In your CI configuration
services:
  test:
    image: python:3.12
    depends_on:
      - postgres
    environment:
      POSTGRES_HOST: postgres
      POSTGRES_DB: test_db
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
    command: pytest tests/

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: test_db
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
```

### Examples

See the `examples/` directory for comprehensive usage examples:
- `integration_test_example.py` - Multiple integration testing patterns
- `production_init_example.py` - Production database initialization

For more details, see the [Database Initializer documentation](#database-initialization).

## Database Initialization

The `DatabaseInitializer` utility can be used for both testing and production scenarios.

### Features

- **Database lifecycle management**: Create, setup, teardown databases
- **Schema management**: Apply SQL schema files
- **Sample data loading**: Load test data from scripts
- **Health checks**: Verify database connectivity
- **Context manager support**: Automatic cleanup
- **Production-ready**: Environment-specific configurations

### Use Cases

1. **Integration Testing**: Setup/teardown test databases
2. **Development**: Initialize development databases with sample data
3. **Production Deployment**: Initial database setup
4. **Blue-Green Deployments**: Prepare new database instances
5. **Health Checks**: Kubernetes readiness/liveness probes

### Basic Usage

```python
from axai_pg.utils import DatabaseInitializer, DatabaseInitializerConfig
from axai_pg.data.config.database import PostgresConnectionConfig

# Configure
config = DatabaseInitializerConfig(
    connection_config=PostgresConnectionConfig.from_env(),
    auto_create_db=True,
    auto_drop_on_exit=False  # Set True for tests
)

# Initialize
db_init = DatabaseInitializer(config)
db_init.setup_database(load_sample_data=False)

# Use database
db_manager = db_init.get_database_manager()
with db_manager.session_scope() as session:
    # Perform operations
    pass

# Cleanup when done
db_init.teardown_database()
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT
